#!/bin/bash
#!/bin/bash
DIR=`dirname "$0"`
#echo "DIR='$DIR'"
pushd "$DIR" >/dev/null
BINDIR=`pwd`
#echo "BINDIR='$BINDIR'"
popd > /dev/null
export _CATFILE="$BINDIR/`basename $0`"
export _CALLING_SCRIPT=`basename $0`
#echo "me:$_CATFILE"
firstcheck=`mktemp`
fglrun -V > $firstcheck
if [ $? -ne 0 ]
then
  rm -f $firstcheck
  echo "ERROR: no fglrun in the path"
  exit 1
fi
ver=`cat $firstcheck | sed -n '/Genero virtual machine/q;p'`
major=`echo $ver | sed -n 's/^.* \([0-9]*\)\.\([0-9]*\).*$/\1/p'`
rm -f $firstcheck
if [ $major -lt 3 ]
then
  echo "ERROR:fglrun version should be >= 3.0 ,current:$ver"
  exit 1
fi

replace_dot(){
# replace dot with underscore
  local dir=`dirname $1`
  local base=`basename $1`
#genero doesn't like dots in the filename
  base=`echo $base | sed -e 's/\./_/g'`
  echo "$dir/$base"
}

# compute a unique temp filename and a unique directory
# without dots in the name
while true
do
  _tmpfile=`mktemp`
  _tmpdir_extractor=`dirname $_tmpfile`
  rm -f $_tmpfile
  _tmpfile=`replace_dot $_tmpfile`

  _TMPDIR=`mktemp -d`
  rm -rf $_TMPDIR
  export _TMPDIR=`replace_dot $_TMPDIR`

  if [ ! -e $_tmpfile ] && [ ! -e $_TMPDIR ]
  then
    break
  fi
done
#echo "_tmpfile:$_tmpfile,_tmpdir_extractor:$_tmpdir_extractor,_TMPDIR:$_TMPDIR"

#we insert catsource.4gl on the next lines
cat >$_tmpfile.4gl <<EOF
--note: some 4gl constructs in this file are there to surround the pitfalls
--of echo'ing this file with the windows echo command to a temp 4gl file
--percent signs are avoided as well as or signs, thats why we avoid
--the sfmt operator and the cat operator and mixing quotes with double quotes
OPTIONS SHORT CIRCUIT
IMPORT util
IMPORT os
DEFINE tmpdir,fname,full,lastmodule STRING
DEFINE m_bat INT
DEFINE singlequote,doublequote,backslash,percent,dollar STRING
DEFINE m_binTypeArr,m_resTypeArr,m_imgarr,m_resarr DYNAMIC ARRAY OF STRING
MAIN
  DEFINE line,err,catfile STRING
  DEFINE ch,chw base.Channel
  DEFINE sb base.StringBuffer
  DEFINE write,writebin INT
  LET singlequote=ASCII(39)
  LET doublequote=ASCII(34)
  LET backslash=ASCII(92) --we must not use the literal here
  LET percent=ASCII(37)
  LET dollar=ASCII(36)
  LET m_binTypeArr[m_binTypeArr.getLength()+1]='png' 
  LET m_binTypeArr[m_binTypeArr.getLength()+1]='jpg'
  LET m_binTypeArr[m_binTypeArr.getLength()+1]='bmp'
  LET m_binTypeArr[m_binTypeArr.getLength()+1]='gif'
  LET m_binTypeArr[m_binTypeArr.getLength()+1]='tiff'
  LET m_binTypeArr[m_binTypeArr.getLength()+1]='wav'
  LET m_binTypeArr[m_binTypeArr.getLength()+1]='mp3'
  LET m_binTypeArr[m_binTypeArr.getLength()+1]='aiff'
  LET m_binTypeArr[m_binTypeArr.getLength()+1]='mpg'

  LET m_resTypeArr[m_resTypeArr.getLength()+1]='per' 
  LET m_resTypeArr[m_resTypeArr.getLength()+1]='4st'
  LET m_resTypeArr[m_resTypeArr.getLength()+1]='4tb'
  LET m_resTypeArr[m_resTypeArr.getLength()+1]='4tm'
  LET m_resTypeArr[m_resTypeArr.getLength()+1]='4sm'
  LET m_resTypeArr[m_resTypeArr.getLength()+1]='iem'
  LET sb=base.StringBuffer.create()
  LET catfile=fgl_getenv("_CATFILE") --set by calling script
  LET tmpdir=fgl_getenv("_TMPDIR") --set by calling script
  LET m_bat=fgl_getenv("_IS_BAT_FILE") IS NOT NULL
  IF catfile IS NULL OR tmpdir IS NULL THEN
    CALL myerr("_CATFILE or _TMPDIR not set")
  END IF
  IF catfile IS NULL THEN
    LET catfile=arg_val(1)
    LET tmpdir=arg_val(2)
  END IF
  IF NOT m_bat THEN --windows fullPath is clumsy
    LET tmpdir=os.Path.fullPath(tmpdir)
  END IF
  LET ch=base.Channel.create()
  LET chw=base.Channel.create()
  IF NOT os.Path.exists(tmpdir) THEN
    IF NOT os.Path.mkdir(tmpdir) THEN
      LET err="Can't mkdir :",tmpdir
      CALL myerr(err)
    END IF
  END IF
  CALL ch.openFile(catfile,"r")
  WHILE (line:=ch.readLine()) IS NOT NULL
    CASE
       WHEN m_bat AND line.getIndexOf("rem __CAT_EOF_BEGIN__:",1)==1
         LET fname=line.subString(23,line.getLength())
         GOTO mark1
       WHEN (NOT m_bat) AND  line.getIndexOf("#__CAT_EOF_BEGIN__:",1)==1
         LET fname=line.subString(20,line.getLength())
       LABEL mark1:
         LET full=os.Path.join(tmpdir,fname)
         CALL checkSubdirs()
         IF isBinary(fname) THEN
           LET writebin=TRUE
           CALL addDir(m_imgarr,os.Path.dirName(fname))
           CALL sb.clear()
         ELSE
           IF isResource(fname) THEN
             CALL addDir(m_resarr,os.Path.dirName(fname))
           END IF
           LET write=TRUE
           CALL chw.openFile(full,"w")
         END IF
       WHEN ((NOT m_bat) AND line=="#__CAT_EOF_END__") OR
            (m_bat AND line=="rem __CAT_EOF_END__")
         IF writebin THEN
           LET writebin=FALSE
           CALL util.Strings.base64Decode(sb.toString(),full)
         ELSE
           LET write=FALSE
           CALL chw.close()
           CALL eventuallyCompileFile()
         END IF
       WHEN writebin
         CALL sb.append(line.subString(IIF(m_bat,5,2),line.getLength()))
       WHEN write
         CALL chw.writeLine(line.subString(IIF(m_bat,5,2),line.getLength()))
    END CASE
  END WHILE
  CALL ch.close()
  CALL runLastModule()
END MAIN

FUNCTION addDir(arr,dirname)
  DEFINE arr DYNAMIC ARRAY OF STRING
  DEFINE dirname STRING
  DEFINE i INT
  FOR i=1 TO arr.getLength()
    IF arr[i]=dirname THEN
      RETURN --already contained
    END IF
  END FOR
  LET arr[arr.getLength()+1]=dirname
END FUNCTION

FUNCTION setPathFor(arr,envName,cmd)
  DEFINE arr DYNAMIC ARRAY OF STRING
  DEFINE envName,tmp STRING
  DEFINE cmd STRING
  DEFINE i INT
  IF arr.getLength()>0 THEN
    LET tmp=envName,"="
    LET cmd=cmd,IIF(m_bat,"set ",""),tmp
    IF fgl_getenv(envName) IS NOT NULL THEN
      IF m_bat THEN
        LET cmd=percent,envName,percent,";"
      ELSE
        LET cmd=dollar,envName,":"
      END IF
    END IF
    FOR i=1 TO arr.getLength()
        IF i>1 THEN
          LET cmd=cmd,IIF(m_bat,";",":")
        END IF
        LET cmd=cmd,quotePath(os.Path.join(tmpdir,arr[i]))
    END FOR
    LET cmd=cmd,IIF(m_bat,"&&"," ")
  END IF
  RETURN cmd
END FUNCTION

FUNCTION runLastModule() --we must get argument quoting right
  DEFINE i INT
  DEFINE arg,cmd,cmdsave,image2font STRING
  IF lastmodule IS NULL THEN RETURN END IF
  LET cmd=setPathFor(m_resarr,"FGLRESOURCEPATH",cmd)
  LET image2font=os.Path.join(os.Path.join(fgl_getenv("FGLDIR"),"lib"),"image2font.txt")
  LET cmdsave=cmd
  LET cmd=setPathFor(m_imgarr,"FGLIMAGEPATH",cmd)
  IF cmd!=cmdsave AND os.Path.exists(image2font) THEN
    IF m_bat THEN
      LET cmd=cmd.subString(1,cmd.getLength()-2),";",quotePath(image2font),"&&"
    ELSE
      LET cmd=cmd.subString(1,cmd.getLength()-1),":",quotePath(image2font)," "
    END IF
  END IF
  LET cmd=cmd,"fglrun ",os.Path.join(tmpdir,lastmodule)
  FOR i=1 TO num_args()
    LET arg=arg_val(i)
    CASE
      WHEN m_bat AND arg.getIndexOf(' ',1)==0 AND 
                     arg.getIndexOf(doublequote,1)==0
        LET cmd=cmd,' ',arg --we don't need quotes
      WHEN m_bat OR arg.getIndexOf(singlequote,1)!=0 
        --we must use double quotes on windows
        LET cmd=cmd,' ',doublequote,quoteDouble(arg),doublequote
      OTHERWISE
        --sh: you can't quote single quotes inside single quotes
        --everything else does not need to be quoted
        LET cmd=cmd,' ',singlequote,arg,singlequote
    END CASE
  END FOR
  --DISPLAY "cmd:",cmd
  CALL myrun(cmd)
END FUNCTION

FUNCTION quotePath(p)
  DEFINE p STRING
  --TODO: quote space with backlash space
  --IF NOT m_bat AND p.getIndexOf(" ",1)!=0
    --RETURN quoteSpace(p)
  --END IF
  RETURN p
END FUNCTION

FUNCTION myerr(err)
  DEFINE err STRING
  DISPLAY "ERROR:",err
  EXIT PROGRAM 1
END FUNCTION

FUNCTION eventuallyCompileFile()
  DEFINE cmd STRING
  CASE
    WHEN os.Path.extension(fname)=="4gl"
      LET cmd="cd ",tmpdir," && fglcomp -M ",fname
      CALL myrun(cmd)
      --DISPLAY "dirname:",fname,",basename:",os.Path.baseName(fname)
      LET lastmodule=os.Path.baseName(fname)
      --cut extension
      LET lastmodule=lastmodule.subString(1,lastmodule.getLength()-4)
      --DISPLAY "lastmodule=",lastmodule
    WHEN os.Path.extension(fname)=="per"
      LET cmd="cd ",tmpdir," && fglform -M ",fname
      CALL myrun(cmd)
    --other (resource) files are just copied
  END CASE
END FUNCTION

FUNCTION myrun(cmd)
  DEFINE cmd STRING, code INT
  --DISPLAY "myrun:",cmd
  RUN cmd RETURNING code
  IF code THEN
    EXIT PROGRAM 1
  END IF
END FUNCTION

FUNCTION checkSubdirs()
  DEFINE i,found INT
  DEFINE dir,err STRING
  DEFINE dirs DYNAMIC ARRAY OF STRING
  LET dir=os.Path.fullPath(os.Path.dirName(full))
  WHILE TRUE
    CASE
      WHEN dir IS NULL
        EXIT WHILE
      WHEN dir==tmpdir
        LET found=true
        EXIT WHILE
      OTHERWISE
        CALL dirs.insertElement(1)
        LET dirs[1]=dir
    END CASE
    LET dir=os.Path.fullPath(os.Path.dirName(dir))
  END WHILE
  IF NOT found THEN
    --we can't use sfmt because of .bat echo pitfalls
    LET err=singlequote,fname,singlequote,' does point outside'
    CALL myerr(err)
  END IF
  FOR i=1 TO dirs.getLength()
    LET dir=dirs[i]
    IF NOT os.Path.exists(dir) THEN
      IF NOT os.Path.mkdir(dir) THEN
        LET err="Can't create directory:",dir
        CALL myerr(err)
      END IF
    END IF
  END FOR
END FUNCTION

FUNCTION quoteDouble(s)
  DEFINE s STRING
  DEFINE c STRING
  DEFINE i INT
  DEFINE sb base.StringBuffer
  LET sb=base.StringBuffer.create()
  FOR i=1 TO s.getLength()
    LET c=s.getCharAt(i)
    CASE
      WHEN c==doublequote
        CALL sb.append(backslash)
      WHEN (NOT m_bat) AND  c==backslash
        CALL sb.append(backslash)
    END CASE
    CALL sb.append(c)
  END FOR
  RETURN sb.toString()
END FUNCTION

FUNCTION isInArray(arr,fname)
  DEFINE arr DYNAMIC ARRAY OF STRING
  DEFINE fname,ext STRING
  DEFINE i INT
  LET ext=os.Path.extension(fname)
  FOR i=1 TO arr.getLength()
    IF arr[i]==ext THEN 
      RETURN TRUE
    END IF
  END FOR
  RETURN FALSE
END FUNCTION

FUNCTION isBinary(fname)
  DEFINE fname STRING
  RETURN isInArray(m_binTypeArr,fname)
END FUNCTION

FUNCTION isResource(fname)
  DEFINE fname STRING
  RETURN isInArray(m_resTypeArr,fname)
END FUNCTION

EOF

#now compile and run catsource from the temp location
pushd `pwd` > /dev/null
cd $_tmpdir_extractor
mybase=`basename $_tmpfile`
fglcomp -M $mybase.4gl
if [ $? -ne 0 ]
then
  exit 1
fi
rm -f $mybase.4gl
popd > /dev/null
fglrun $_tmpfile.42m "$@"
mycode=$?
rm -f $_tmpfile.42m
rm -rf $_TMPDIR
exit $mycode
#__CAT_EOF_BEGIN__:fglunzip_version.inc
#public CONSTANT GIT_VERSION="1.00.00dev"
#public CONSTANT GIT_COMMIT_COUNT=9
#public CONSTANT GIT_REV="gd37392ae"
#__CAT_EOF_END__
#__CAT_EOF_BEGIN__:myassert.inc
#&define MYERRCALL myErr
#&define MYASSERT(x) IF NOT NVL(x,0) THEN CALL MYERRCALL("ASSERTION failed in line:"||__LINE__||":"||#x) END IF
#&define MYASSERT_MSG(x,msg) IF NOT NVL(x,0) THEN CALL MYERRCALL("ASSERTION failed in line:"||__LINE__||":"||#x||","||msg) END IF
#&define UNUSED_VAR(variable) IF (variable) IS NULL THEN END IF
#__CAT_EOF_END__
#__CAT_EOF_BEGIN__:mygetopt.4gl
##+ the fgl getopt module backported to 3.10
#IMPORT os
#
##+ GetoptOptions.arg_type flag: Option has no value argument.
#PUBLIC CONSTANT NONE = 1
##+ GetoptOptions.arg_type flag: Option has a mandatory value argument.
#PUBLIC CONSTANT REQUIRED = 2
##+ GetoptOptions.arg_type flag: Option has an optional value argument.
#PUBLIC CONSTANT OPTIONAL = 3
#
##+ getopt() method status: Last argument processing succeeded.
#PUBLIC CONSTANT SUCCESS = 0
##+ getopt() method status: All possible options have been processed.
#PUBLIC CONSTANT EOF = 1
##+ getopt() method status: The last option processing failed.
#PUBLIC CONSTANT BAD_OPTION = 2
#
#PRIVATE CONSTANT ALIGN_SIZE = 30 # Alignment of usage display
#
##+
##+ Getopt array of option definitions
##+
##+ This type defines a dynamic array of a record structure to hold command line
##+ options definitions information.
##+ Define a variable of the getopt.GetoptOptions type and fill it with an
##+ array initializer.
##+ Once the array is initialized, it can be passed to the initDefault() or
##+ initialize() method, to setup a Getopt variable in order to process
##+ command line arguments with the getopt() method.
##+
##+ Record members:
##+
##+ -  name: defines the long name of the command line option.
##+
##+ -  description: is the text to explain the command line option.
##+
##+ -  opt_char: is the single-char command line option name.
##+
##+ -  arg_type: can be one of getopt.NONE, getopt.OPTIONAL, getopt.REQUIRED
##+
#PUBLIC TYPE GetoptOptions DYNAMIC ARRAY OF RECORD
#  name STRING,
#  description STRING,
#  opt_char CHAR,
#  arg_type INTEGER
#END RECORD
#
##+
##+ Getopt object type
##+
##+ This type defines the Getopt record that is used with getopt methods to
##+ parse and validate command line options.
##+ A variable of the type Getopt must be defined and initialized with the
##+ initDefault() or initialize() method, before using the getopt() method
##+ in a WHILE loop, to process command line options.
##+ After initializing the Getopt variable, the argv dynamic array contains
##+ all command line arguments starting from the index offset provided to
##+ the initialize() method.
##+
##+ Record members:
##+
##+ -  opt_ind: Current command line argument index that is processed.
##+
##+ -  opt_char: The single-character short name of the current processed option.
##+
##+ -  opt_arg: If present, holds the value parameter of the processed option
##+             (--option=value). Otherwise, this member is NULL.
##+
#PUBLIC TYPE Getopt RECORD
#  # Private members - don't modify
#  argv DYNAMIC ARRAY OF STRING,
#  status INTEGER,
#  _options GetoptOptions,
#  prog_name STRING,
#  next_char STRING,
#  option_index INTEGER,
#
#  # Public read only members
#  opt_ind INTEGER,
#  opt_char CHAR,
#  opt_arg STRING
#END RECORD
#
#PUBLIC TYPE GetoptR DYNAMIC ARRAY OF Getopt
#
#MAIN
#  DEFINE gr GetoptR
#  DEFINE _options GetoptOptions
#  { =
#      [(name: "version",
#              description: "Version information",
#              opt_char: 'v',
#              arg_type: NONE),
#          (name: "help",
#              description: "This help page",
#              opt_char: 'h',
#              arg_type: NONE),
#          (name: "hello",
#              description: "Hello everybody!",
#              opt_char: NULL,
#              arg_type: REQUIRED),
#          (name: "bonjour",
#              description: "Bonjour tout le monde!",
#              opt_char: 'B',
#              arg_type: OPTIONAL),
#          (name: "number",
#              description: "Accept also negativ numbers",
#              opt_char: 'n',
#              arg_type: REQUIRED)]
#
#
#  }
#  DEFINE ind, option_index INTEGER
#  DEFINE cnt INTEGER
#  DEFINE opt_char, opt_arg STRING
#
#  -- CALL g.initDefault(_options)
#  CALL initialize(gr, arg_val(0), copyArguments(1), _options)
#
#  WHILE getopt(gr) == SUCCESS
#    LET opt_char = opt_char(gr)
#    LET opt_arg = opt_arg(gr)
#    LET option_index = option_index(gr)
#
#    CASE opt_char
#      WHEN 'v'
#        DISPLAY "Version: 1.54"
#      WHEN 'h'
#        CALL displayUsage(gr, "filename ...")
#      WHEN 'H'
#        DISPLAY "Got option -H and value arg is ", opt_arg
#      WHEN 'B'
#        IF opt_arg IS NOT NULL THEN
#          DISPLAY "Got option -B and value arg is ", opt_arg
#        ELSE
#          DISPLAY "Got option -B and no arg"
#        END IF
#      WHEN 'n'
#        DISPLAY "Got option -n and value arg is ", opt_arg
#      OTHERWISE
#        IF opt_char IS NULL THEN
#          DISPLAY "Got long option ", _options[option_index].name
#          CASE _options[option_index].name
#            WHEN "hello"
#              DISPLAY "Got option --hello and arg is ", opt_arg
#          END CASE
#        END IF
#    END CASE
#  END WHILE
#
#  IF invalidOptionSeen(gr) THEN # ERROR
#    CALL displayUsage(gr, "filename ...")
#    EXIT PROGRAM 1
#  ELSE
#    LET cnt = getMoreArgumentCount(gr)
#    IF cnt > 0 THEN
#      FOR ind = 1 TO cnt
#        DISPLAY SFMT("Additional argument: %1", getMoreArgument(gr, ind))
#      END FOR
#    END IF
#  END IF
#
#END MAIN
#
#PUBLIC FUNCTION opt_arg(gr GetoptR) RETURNS STRING
#  RETURN gr[1].opt_arg
#END FUNCTION
#
#PUBLIC FUNCTION opt_char(gr GetoptR) RETURNS STRING
#  RETURN gr[1].opt_char
#END FUNCTION
#
#PUBLIC FUNCTION option_index(gr GetoptR) RETURNS STRING
#  RETURN gr[1].option_index
#END FUNCTION
#
##+ Copy the command line arguments into an array of string
##+
##+ @param ind First argument to copy
##+
##+ @return An array of string
#PUBLIC FUNCTION copyArguments(ind INTEGER) RETURNS DYNAMIC ARRAY OF STRING
#  DEFINE argv DYNAMIC ARRAY OF STRING
#  DEFINE i INTEGER
#  DEFINE argc INTEGER
#
#  LET argc = 0
#  FOR i = ind TO num_args()
#    LET argc = argc + 1
#    LET argv[argc] = arg_val(i)
#  END FOR
#  RETURN argv
#END FUNCTION
#
#PUBLIC FUNCTION copyArgumentsFromArr(
#    argsarr DYNAMIC ARRAY OF STRING, ind INTEGER)
#    RETURNS DYNAMIC ARRAY OF STRING
#  DEFINE argv DYNAMIC ARRAY OF STRING
#  DEFINE i INTEGER
#  DEFINE argc INTEGER
#
#  LET argc = 0
#  FOR i = ind TO argsarr.getLength()
#    LET argc = argc + 1
#    LET argv[argc] = argsarr[i]
#  END FOR
#  RETURN argv
#END FUNCTION
#
##+ Expand argument list (@file)
##+
##+ @param argv The arguments list to expand
##+
##+ @return An array of string
#PRIVATE FUNCTION expandArguments(
#    argv DYNAMIC ARRAY OF STRING)
#    RETURNS(INTEGER, DYNAMIC ARRAY OF STRING)
#  DEFINE rv DYNAMIC ARRAY OF STRING
#  DEFINE i INTEGER
#  DEFINE argc INTEGER
#  DEFINE arg STRING
#  --DEFINE ch base.Channel
#  --DEFINE fileName STRING
#  --DEFINE ln STRING
#
#  LET argc = 0
#  FOR i = 1 TO argv.getLength()
#    LET arg = argv[i]
#    {IF arg.subString(1, 1) == '@' THEN
#      LET fileName = arg.subString(2, arg.getLength())
#      IF NOT os.Path.exists(fileName) THEN
#        DISPLAY SFMT("getopt: File %1 not found.", fileName)
#        RETURN BAD_OPTION, NULL
#      END IF
#      LET ch = base.Channel.create()
#      CALL ch.openFile(fileName, "r")
#      WHILE (ln := ch.readLine()) IS NOT NULL
#        LET ln = ln.trim()
#        IF ln.getLength() > 0 THEN
#          LET argc = argc + 1
#          LET rv[argc] = ln
#        END IF
#      END WHILE
#      CALL ch.close()
#    ELSE}
#    LET argc = argc + 1
#    LET rv[argc] = argv[i]
#    {END IF}
#  END FOR
#
#  RETURN SUCCESS, rv
#END FUNCTION
#
##+
##+ Getopt isAnOption method.
##+
##+ This method checks whether a given parameter is an option or not
##+
##+ @param param The parameter string you want to check if it is an option
##+
##+ @return TRUE if parameter is a valid option, FALSE otherwise
##+
#PRIVATE FUNCTION isAnOption(gr GetoptR, param STRING) RETURNS BOOLEAN
#  # An option must start with - or --
#  IF param.getCharAt(1) == '-' THEN
#    LET param = param.subString(2, param.getLength())
#    IF param.getCharAt(1) == '-' THEN
#      # Handle long option
#      LET param = param.subString(2, param.getLength())
#      IF gr[1]._options.search("name", param) > 0 THEN
#        RETURN TRUE # Is a long option
#      END IF
#    ELSE
#      IF param.getLength() == 1 THEN
#        # Handle short option
#        IF gr[1]._options.search("opt_char", param) > 0 THEN
#          RETURN TRUE # Is a short option
#        END IF
#      END IF
#    END IF
#  END IF
#  RETURN FALSE
#END FUNCTION
#
##+
##+ Getopt object initialization method.
##+
##+ This method initializes the Getopt object by using the program name passed
##+ as parameter, a dynamic array of strings with the arguments to process, and
##+ the definition of the options of the program.
##+
##+ The second parameter (argv) can be used to implement command line syntax
##+ with a verb as first argument:
##+
##+ @code
##+ fglrun myprog capture --verbose --filename=file1
##+ fglrun myprog duplicate --source=file1 --destination=file2
##+
##+ The argv list can be provided with the copyArguments(index) function.
##+
##+ @param prog_name  The name of the program
##+ @param argv       The program arguments
##+ @param options    The GetoptOptions array of options definitions
##+
##+
#PUBLIC FUNCTION initialize(
#    gr GetoptR,
#    prog_name STRING,
#    argv DYNAMIC ARRAY OF STRING,
#    options GetoptOptions)
#  LET gr[1].prog_name = prog_name
#  LET gr[1].next_char = NULL
#  LET gr[1].opt_ind = 0
#  LET gr[1].opt_char = ""
#  LET gr[1].opt_arg = NULL
#  LET gr[1].status = SUCCESS
#  CALL options.copyTo(gr[1]._options)
#  CALL expandArguments(argv) RETURNING gr[1].status, gr[1].argv
#END FUNCTION
#
##+
##+ Default Getopt object initialization method.
##+
##+ This method initializes the Getopt object by using arg_val(0) as program
##+ name and starting command line argument processing at index 1.
##+
##+ @param options    The GetoptOptions array of options definitions
##+
#PUBLIC FUNCTION initDefault(gr GetoptR, options GetoptOptions)
#  CALL initialize(gr, os.Path.baseName(arg_val(0)), copyArguments(1), options)
#END FUNCTION
#
##+
##+ Returns the number of arguments left, which are not part of the options,
##+ or -1 if the options are not yet fully parsed.
##+
##+ @return The number of additional arguments.
##+
#PUBLIC FUNCTION getMoreArgumentCount(gr GetoptR) RETURNS INTEGER
#  IF gr[1].status == EOF THEN
#    RETURN gr[1].argv.getLength() - gr[1].opt_ind + 1
#  END IF
#  RETURN -1
#END FUNCTION
#
##+
##+ Returns the argument not part of the options, at the specified index.
##+
##+ The index starts at 1, for the first argument after the last option
##+ (The index offset resulting from the used options is taken into account).
##+
##+ Returns NULL if the index is not valid.
##+
##+ @code
##+ LET cnt = g.getMoreArgumentCount()
##+ IF cnt THEN
##+     FOR ind = 1 TO cnt
##+         DISPLAY SFMT("Additional argument: %1", g.getMoreArgument(ind))
##+     END FOR
##+ END IF
##+
##+ @param ind The (offset-adapted) index of the additional argument.
##+
##+ @return The value of the additional argument.
##+
#PUBLIC FUNCTION getMoreArgument(gr GetoptR, ind INTEGER) RETURNS STRING
#  DEFINE x INTEGER
#  LET x = gr[1].opt_ind + ind - 1
#  IF x > 0 AND x <= gr[1].argv.getLength() THEN
#    RETURN gr[1].argv[x]
#  ELSE
#    RETURN NULL
#  END IF
#END FUNCTION
#
##+
##+ This method can be used while processing command line options with getopt(),
##+ to check if there are more options to be processed.
##+
##+ @return TRUE if the option parsing is done.
##+
#PUBLIC FUNCTION isEof(gr GetoptR) RETURNS BOOLEAN
#  RETURN gr[1].status == EOF
#END FUNCTION
#
##+
##+ This method can be used after processing the command line arguments with
##+ getopt() in a loop, to check if the processing failed because of an invalid
##+ options.
##+
##+ @return TRUE if the option parsing detected an invalid argument.
##+
#PUBLIC FUNCTION invalidOptionSeen(gr GetoptR) RETURNS BOOLEAN
#  RETURN gr[1].status == BAD_OPTION
#END FUNCTION
#
##+
##+ This method can be used after processing the command line arguments with
##+ getopt() in a loop, to check if the processing succeeded.
##+
##+ @return TRUE if the option parsing succeeded.
##+
#PUBLIC FUNCTION isSuccess(gr GetoptR) RETURNS BOOLEAN
#  RETURN gr[1].status == SUCCESS
#END FUNCTION
#
##+
##+ This is the main method to call in a loop, to parse command line arguments
##+ according to the GetoptOptions definitions of the Getopt object.
##+
##+ @code
##+ WHILE g.getopt() == getopt.SUCCESS
##+     CASE g.opt_char
##+         WHEN "v"
##+             DISPLAY "Version: 1.54"
##+             EXIT PROGRAM 0
##+         ...
##+     END CASE
##+ END WHILE
##+
##+ @return The processing status (getopt.SUCCESS | getopt.EOF | getopt.BAD_ARGUMENT)
##+
#PUBLIC FUNCTION getopt(gr GetoptR) RETURNS INTEGER
#  DEFINE arg STRING
#
#  IF gr[1].status != SUCCESS THEN
#    RETURN gr[1].status
#  END IF
#  IF gr[1].next_char IS NULL THEN
#    LET gr[1].opt_ind = gr[1].opt_ind + 1
#
#    # Check if EOF
#    IF gr[1].opt_ind > gr[1].argv.getLength() THEN
#      RETURN eof(gr)
#    END IF
#
#    LET arg = gr[1].argv[gr[1].opt_ind]
#
#    # Parameter is not an option - end of option parsing
#    IF arg.getCharAt(1) != '-' THEN
#      RETURN eof(gr)
#    END IF
#
#    IF arg == "--" THEN
#      LET gr[1].opt_ind = gr[1].opt_ind + 1 # Skip -- end of option marker
#      RETURN eof(gr)
#    END IF
#
#    # Check for long option parameters
#    IF arg.getCharAt(2) == '-' THEN
#      RETURN parseLong(gr)
#    ELSE
#      RETURN parseShort(gr)
#    END IF
#  ELSE
#    # Parse concatenated short options
#    RETURN parseShort(gr)
#  END IF
#END FUNCTION
#
##+
##+ Displays the command line usage of a program.
##+
##+ @param more_args The non option string to add to usage
##+
#PUBLIC FUNCTION displayUsage(gr GetoptR, more_args STRING)
#  DEFINE ind INTEGER
#  DEFINE delta INTEGER
#  DEFINE sb base.StringBuffer
#  LET sb = base.StringBuffer.create()
#  IF more_args IS NOT NULL THEN
#    DISPLAY SFMT("Usage: %1 [options] %2\n", gr[1].prog_name, more_args)
#  ELSE
#    DISPLAY SFMT("Usage: %1 [options]\n", gr[1].prog_name)
#  END IF
#  IF more_args IS NOT NULL THEN
#    DISPLAY "Options:"
#  END IF
#  FOR ind = 1 TO gr[1]._options.getLength()
#    CALL sb.clear()
#    IF gr[1]._options[ind].opt_char IS NULL THEN
#      CASE gr[1]._options[ind].arg_type
#        WHEN NONE
#          CALL sb.append(SFMT("    --%1", gr[1]._options[ind].name))
#        WHEN OPTIONAL
#          CALL sb.append(SFMT("    --%1 [<arg>]", gr[1]._options[ind].name))
#        WHEN REQUIRED
#          CALL sb.append(SFMT("    --%1 <arg>", gr[1]._options[ind].name))
#      END CASE
#    ELSE
#      CASE gr[1]._options[ind].arg_type
#        WHEN NONE
#          CALL sb.append(
#              SFMT("    -%1, --%2",
#                  gr[1]._options[ind].opt_char, gr[1]._options[ind].name))
#        WHEN OPTIONAL
#          CALL sb.append(
#              SFMT("    -%1, --%2 [<arg>]",
#                  gr[1]._options[ind].opt_char, gr[1]._options[ind].name))
#        WHEN REQUIRED
#          CALL sb.append(
#              SFMT("    -%1, --%2 <arg>",
#                  gr[1]._options[ind].opt_char, gr[1]._options[ind].name))
#      END CASE
#    END IF
#    IF sb.getLength() <= ALIGN_SIZE THEN
#      LET delta = ALIGN_SIZE - sb.getLength()
#      DISPLAY SFMT("%1%2%3",
#          sb.toString(), delta SPACES, gr[1]._options[ind].description)
#    ELSE
#      DISPLAY SFMT("%1\n%2%3",
#          sb.toString(), ALIGN_SIZE SPACES, gr[1]._options[ind].description)
#    END IF
#  END FOR
#END FUNCTION
#
## Set status to EOF
#PRIVATE FUNCTION eof(gr GetoptR) RETURNS INTEGER
#  LET gr[1].opt_char = NULL
#  LET gr[1].opt_arg = NULL
#  LET gr[1].status = EOF
#  RETURN gr[1].status
#END FUNCTION
#
## Set status to BAD_OPTION
#PRIVATE FUNCTION bad_option(gr GetoptR) RETURNS INTEGER
#  LET gr[1].opt_char = NULL
#  LET gr[1].opt_arg = NULL
#  LET gr[1].status = BAD_OPTION
#  RETURN gr[1].status
#END FUNCTION
#
## Parse current argument as a long option name
#PRIVATE FUNCTION parseLong(gr GetoptR) RETURNS INTEGER
#  DEFINE arg STRING
#  DEFINE equal_sign_index INTEGER
#  DEFINE ind INTEGER
#  DEFINE opt STRING
#  DEFINE opt_found INTEGER
#  DEFINE arg_key STRING
#  DEFINE arg_val STRING
#  DEFINE ambiguous BOOLEAN
#  DEFINE exact BOOLEAN
#
#  LET arg = gr[1].argv[gr[1].opt_ind]
#
#  # Split arg in key=value or just key
#  LET equal_sign_index = arg.getIndexOf("=", 3)
#  IF equal_sign_index > 3 THEN
#    LET arg_key = arg.subString(3, equal_sign_index - 1)
#    LET arg_val = arg.subString(equal_sign_index + 1, arg.getLength())
#  ELSE
#    LET arg_key = arg.subString(3, arg.getLength())
#    LET arg_val = NULL
#  END IF
#
#  # Search through all options to get an exact match, a partial match, and ensure
#  # partial match is unique or else we have an ambiguous match, which has to be rejected.
#  FOR ind = 1 TO gr[1]._options.getLength()
#    LET opt = gr[1]._options[ind].name
#    IF arg_key.equals(opt) THEN
#      LET opt_found = ind
#      LET exact = TRUE
#      EXIT FOR
#    ELSE
#      IF opt.getIndexOf(arg_key, 1) > 0 THEN
#        IF NOT opt_found THEN
#          LET opt_found = ind
#        ELSE
#          LET ambiguous = TRUE
#        END IF
#      END IF
#    END IF
#  END FOR
#
#  IF ambiguous AND NOT exact THEN
#    DISPLAY SFMT("%1: ambiguous match: --%2", gr[1].prog_name, arg_key)
#    RETURN bad_option(gr)
#  END IF
#
#  IF opt_found == 0 THEN
#    DISPLAY SFMT("%1: invalid option: --%2", gr[1].prog_name, arg_key)
#    RETURN bad_option(gr)
#  END IF
#
#  LET gr[1].option_index = opt_found
#  # Check for argument value
#  IF arg_val IS NOT NULL THEN
#    CASE gr[1]._options[opt_found].arg_type
#      WHEN NONE
#        DISPLAY SFMT("%1: erroneous argument: --%2", gr[1].prog_name, arg_key)
#        RETURN BAD_OPTION
#      OTHERWISE
#        LET gr[1].opt_char = gr[1]._options[opt_found].opt_char
#        LET gr[1].opt_arg = arg_val
#        RETURN SUCCESS
#    END CASE
#  END IF
#
#  # Check there is no parameter
#  IF gr[1]._options[opt_found].arg_type == NONE THEN
#    LET gr[1].opt_char = gr[1]._options[opt_found].opt_char
#    LET gr[1].opt_arg = NULL
#    RETURN SUCCESS
#  ELSE
#    # Otherwise optional or required
#    IF gr[1].opt_ind + 1 <= gr[1].argv.getLength() THEN
#      IF NOT isAnOption(gr, gr[1].argv[gr[1].opt_ind + 1]) THEN
#        # Found parameter
#        LET gr[1].opt_ind = gr[1].opt_ind + 1
#        LET gr[1].opt_char = gr[1]._options[opt_found].opt_char
#        LET gr[1].opt_arg = gr[1].argv[gr[1].opt_ind]
#        RETURN SUCCESS
#      END IF
#    END IF
#    # Parameter optional, return success
#    IF gr[1]._options[opt_found].arg_type == OPTIONAL THEN
#      LET gr[1].opt_char = gr[1]._options[opt_found].opt_char
#      LET gr[1].opt_arg = NULL
#      RETURN SUCCESS
#    END IF
#  END IF
#
#  DISPLAY SFMT("%1: missing argument: --%2", gr[1].prog_name, arg_key)
#  RETURN bad_option(gr)
#
#END FUNCTION
#
## Parse current argument as a short option name
#PRIVATE FUNCTION parseShort(gr GetoptR) RETURNS INTEGER
#  DEFINE arg STRING
#  DEFINE equal_sign_index INTEGER
#  DEFINE ind INTEGER
#  DEFINE opt_found INTEGER
#  DEFINE arg_key STRING
#  DEFINE arg_val STRING
#
#  IF gr[1].next_char IS NULL THEN
#    LET arg = gr[1].argv[gr[1].opt_ind]
#
#    # Split arg in key=value or just key
#    LET equal_sign_index = arg.getIndexOf("=", 2)
#    IF equal_sign_index > 2 THEN
#      LET arg_key = arg.subString(2, equal_sign_index - 1)
#      LET arg_val = arg.subString(equal_sign_index + 1, arg.getLength())
#    ELSE
#      LET arg_key = arg.subString(2, arg.getLength())
#      IF arg_key.getLength() > 1 THEN
#        LET gr[1].next_char = arg_key.subString(2, arg_key.getLength())
#        LET arg_key = arg_key.subString(1, 1)
#      ELSE
#        LET gr[1].next_char = NULL
#      END IF
#      LET arg_val = NULL
#    END IF
#  ELSE
#    # Parse concatenated short option
#    LET arg_key = gr[1].next_char.subString(1, 1)
#    IF gr[1].next_char.getLength() > 1 THEN
#      LET gr[1].next_char =
#          gr[1].next_char.subString(2, gr[1].next_char.getLength())
#    ELSE
#      LET gr[1].next_char = NULL
#    END IF
#    LET arg_val = NULL
#  END IF
#
#  # Lookup for single char
#  FOR ind = 1 TO gr[1]._options.getLength()
#    IF arg_key.equals(gr[1]._options[ind].opt_char) THEN
#      LET opt_found = ind
#      EXIT FOR
#    END IF
#  END FOR
#
#  IF opt_found == 0 THEN
#    DISPLAY SFMT("%1: invalid option character: -%2", gr[1].prog_name, arg_key)
#    RETURN bad_option(gr)
#  END IF
#
#  LET gr[1].option_index = opt_found
#  # Check there is no parameter
#  IF gr[1]._options[opt_found].arg_type == NONE THEN
#    IF arg_val IS NOT NULL THEN
#      DISPLAY SFMT("%1: erroneous argument: -%2", gr[1].prog_name, arg_key)
#      RETURN bad_option(gr)
#    ELSE
#      LET gr[1].opt_char = gr[1]._options[opt_found].opt_char
#      LET gr[1].opt_arg = NULL
#      RETURN SUCCESS
#    END IF
#  ELSE
#    # Otherwise optional or required
#    IF arg_val IS NOT NULL THEN
#      LET gr[1].opt_char = gr[1]._options[opt_found].opt_char
#      LET gr[1].opt_arg = arg_val
#      RETURN SUCCESS
#    END IF
#    IF gr[1].opt_ind + 1 <= gr[1].argv.getLength() THEN
#      IF NOT isAnOption(gr, gr[1].argv[gr[1].opt_ind + 1]) THEN
#        # Found parameter
#        LET gr[1].opt_ind = gr[1].opt_ind + 1
#        LET gr[1].opt_char = gr[1]._options[opt_found].opt_char
#        LET gr[1].opt_arg = gr[1].argv[gr[1].opt_ind]
#        RETURN SUCCESS
#      END IF
#    END IF
#    # Parameter optional, return success
#    IF gr[1]._options[opt_found].arg_type == OPTIONAL THEN
#      LET gr[1].opt_char = gr[1]._options[opt_found].opt_char
#      LET gr[1].opt_arg = NULL
#      RETURN SUCCESS
#    END IF
#  END IF
#
#  DISPLAY SFMT("%1: missing argument: -%2", gr[1].prog_name, arg_key)
#  RETURN bad_option(gr)
#
#END FUNCTION
#__CAT_EOF_END__
#__CAT_EOF_BEGIN__:fglunzip.4gl
#OPTIONS
#SHORT CIRCUIT
#IMPORT os
#IMPORT FGL mygetopt
#&include "fglunzip_version.inc"
#&include "myassert.inc"
#DEFINE _product_zip STRING --the zip file to process
#DEFINE _opt_verbose BOOLEAN
#DEFINE _opt_in_FGLDIR BOOLEAN
#DEFINE _opt_simulate BOOLEAN
#DEFINE _opt_undo BOOLEAN
#DEFINE _opt_plain BOOLEAN
#--DEFINE _stdoutNONL STRING
#--TODO
#--DEFINE _opt_quiet BOOLEAN
#--DEFINE _opt_logfile STRING
#--DEFINE _opt_ext_dir STRING
#MAIN
#  DEFINE argsarr DYNAMIC ARRAY OF STRING
#  DEFINE root om.DomNode
#  DEFINE numChildren INT
#  IF yesno_mode() THEN
#    RETURN
#  END IF
#  CALL checkTar()
#  LET argsarr = setupArgs()
#  --DISPLAY "argsarr:",util.JSON.stringify(argsarr)
#  CALL parseArgs(argsarr)
#  LET root = readFiles()
#  LET numChildren = analyze(root)
#  IF numChildren == 0 THEN
#    CALL userError(SFMT("no entries found in:%1", _product_zip))
#  END IF
#  CALL doit(root, numChildren)
#END MAIN
#
#FUNCTION tarExe()
#  RETURN IIF(isWin(), "tar.exe", "tar")
#END FUNCTION
#
#FUNCTION checkTar()
#  DEFINE tar STRING
#  LET tar = tarExe()
#  IF whichExe(tar) IS NULL THEN
#    CALL userError(
#        SFMT("Couldn't find program:%1 on your system, please install", tar))
#  END IF
#END FUNCTION
#
#FUNCTION unzipList()
#  DEFINE cmd STRING
#  LET cmd = SFMT("%1 tf %2", tarExe(), quote(_product_zip))
#  --DISPLAY "unzipList cmd:", cmd
#  RETURN getProgramOutput(cmd)
#END FUNCTION
#
#FUNCTION setupArgs()
#  DEFINE i INT
#  DEFINE argsarr DYNAMIC ARRAY OF STRING
#  FOR i = 1 TO num_args()
#    LET argsarr[i] = arg_val(i)
#  END FOR
#  RETURN argsarr
#END FUNCTION
#
#PRIVATE FUNCTION parseArgs(argsarr)
#  DEFINE argsarr DYNAMIC ARRAY OF STRING
#  DEFINE gr mygetopt.GetoptR
#  DEFINE o mygetopt.GetoptOptions
#  DEFINE opt_arg STRING
#  DEFINE i, cnt INT
#  DEFINE listSeen INT
#
#  LET i = o.getLength() + 1
#  LET o[i].name = "version"
#  LET o[i].description = "Version information"
#  LET o[i].opt_char = "V"
#  LET o[i].arg_type = mygetopt.NONE
#
#  LET i = o.getLength() + 1
#  LET o[i].name = "help"
#  LET o[i].description = "program help"
#  LET o[i].opt_char = "h"
#  LET o[i].arg_type = mygetopt.NONE
#
#  LET i = o.getLength() + 1
#  LET o[i].name = "verbose"
#  LET o[i].description = "detailed log"
#  LET o[i].opt_char = "v"
#  LET o[i].arg_type = mygetopt.NONE
#
#  LET i = o.getLength() + 1
#  LET o[i].name = "simulate"
#  LET o[i].description = "simulates what would be extracted/undone"
#  LET o[i].opt_char = "s"
#  LET o[i].arg_type = mygetopt.NONE
#
#  LET i = o.getLength() + 1
#  LET o[i].name = "list"
#  LET o[i].description = "Lists the archive content"
#  LET o[i].opt_char = "l"
#  LET o[i].arg_type = mygetopt.NONE
#
#  LET i = o.getLength() + 1
#  LET o[i].name = "use-FGLDIR"
#  LET o[i].description =
#      "installs over FGLDIR to make the product avaiable without further env settings"
#  LET o[i].opt_char = "F"
#  LET o[i].arg_type = mygetopt.NONE
#
#  LET i = o.getLength() + 1
#  LET o[i].name = "like-unzip"
#  LET o[i].description =
#      "extracts multiple files/directories in the root directory of the archive like unzip 'plain' in the current directory"
#  LET o[i].opt_char = "i"
#  LET o[i].arg_type = mygetopt.NONE
#
#  LET i = o.getLength() + 1
#  LET o[i].name = "undo"
#  LET o[i].description = "Reverts the install"
#  LET o[i].opt_char = "u"
#  LET o[i].arg_type = mygetopt.NONE
#
#  { --TODO
#  LET i = o.getLength() + 1
#  LET o[i].name = "quiet"
#  LET o[i].description = "Does install quietly without asking yes/no"
#  LET o[i].opt_char = "q"
#  LET o[i].arg_type = mygetopt.NONE
#
#  LET i = o.getLength() + 1
#  LET o[i].name = "logfile"
#  LET o[i].description = "File written for logs and success"
#  LET o[i].opt_char = "L"
#  LET o[i].arg_type = mygetopt.REQUIRED
#
#  LET i = o.getLength() + 1
#  LET o[i].name = "destination-dir"
#  LET o[i].description =
#      "choose another extraction directory than the current dir"
#  LET o[i].opt_char = "d"
#  LET o[i].arg_type = mygetopt.NONE
#  }
#
#  CALL mygetopt.initialize(gr, "fglunzip", argsarr, o)
#  WHILE mygetopt.getopt(gr) == mygetopt.SUCCESS
#    LET opt_arg = mygetopt.opt_arg(gr)
#    CASE mygetopt.opt_char(gr)
#      WHEN 'V'
#        CALL printVersion()
#        EXIT PROGRAM 0
#      WHEN 'v'
#        LET _opt_verbose = TRUE
#      WHEN 'h'
#        CALL mygetopt.displayUsage(gr, "fjs-<product>.zip")
#        EXIT PROGRAM 0
#      WHEN 'l'
#        LET listSeen = TRUE
#      WHEN 'F'
#        LET _opt_in_FGLDIR = TRUE
#      WHEN 's'
#        LET _opt_simulate = TRUE
#      WHEN 'u'
#        LET _opt_undo = TRUE
#      WHEN 'i'
#        LET _opt_plain = TRUE
#        { --TODO
#        WHEN 'q'
#          LET _opt_quiet = TRUE
#        WHEN 'L'
#          LET _opt_logfile = opt_arg
#        WHEN 'd'
#          LET _opt_ext_dir = opt_arg
#        }
#    END CASE
#  END WHILE
#  IF (cnt := mygetopt.getMoreArgumentCount(gr)) <> 1 THEN
#    CALL mygetopt.displayUsage(gr, "fjs-<product>.zip")
#    EXIT PROGRAM 1
#  END IF
#  LET _product_zip = mygetopt.getMoreArgument(gr, 1)
#  LET _product_zip = os.Path.fullPath(_product_zip)
#  IF listSeen THEN
#    DISPLAY unzipList()
#    EXIT PROGRAM 0
#  END IF
#  { --TODO
#  IF _opt_in_FGLDIR AND _opt_ext_dir IS NOT NULL THEN
#    CALL userError(
#        "option --use-FGLDIR(-F) and --destination-dir(-d) are mutually exclusive")
#  END IF
#  }
#END FUNCTION
#
#PRIVATE FUNCTION readFiles()
#  DEFINE raw STRING
#  DEFINE tok base.StringTokenizer
#  DEFINE path STRING
#  DEFINE doc om.DomDocument
#  DEFINE root {,lastNode} om.DomNode
#  LET doc = om.DomDocument.create("Files")
#  LET root = doc.getDocumentElement()
#  LET raw = unzipList()
#  LET raw = replace(raw, "\r\n", "\n") --windows
#  LET tok = base.StringTokenizer.create(raw, "\n")
#  WHILE tok.hasMoreTokens()
#    LET path = tok.nextToken()
#    IF path.getLength() > 0 THEN
#      CALL addFile(root, path)
#    END IF
#  END WHILE
#  --DISPLAY "readFiles did get:",root.toString()
#  RETURN root
#END FUNCTION
#
#--loop thru the path parts
#PRIVATE FUNCTION findFileNode(parent, path, createIfNotFound)
#  DEFINE path, part, tName, full STRING
#  DEFINE parent, child, newchild om.DomNode
#  DEFINE createIfNotFound, found BOOLEAN
#  DEFINE tok base.StringTokenizer
#  LET tok = base.StringTokenizer.create(path, "/")
#  WHILE tok.hasMoreTokens()
#    LET found = FALSE
#    LET part = tok.nextToken()
#    IF createIfNotFound THEN
#      LET full = IIF(full IS NULL, part, SFMT("%1/%2", full, part))
#    END IF
#    --DISPLAY "begin handle part:",part," for parent:",parent.getTagName(),",full:",full
#    LET child = parent.getFirstChild()
#    WHILE child IS NOT NULL
#      IF child.getAttribute("name") == part THEN
#        LET found = TRUE
#        --DISPLAY sfmt("found childTag:%1 for parent:%2",part,parent.getTagName())
#        LET parent = child
#        EXIT WHILE
#      ELSE
#        LET child = child.getNext()
#      END IF
#    END WHILE
#    IF NOT found THEN
#      IF NOT createIfNotFound THEN
#        RETURN NULL
#      END IF
#      IF path.getCharAt(full.getLength() + 1)
#          == "/" THEN --this full part ends with a slash
#        LET tName = "Dir"
#      ELSE
#        LET tName = "File"
#      END IF
#      LET newchild = parent.createChild(tName)
#      CALL newchild.setAttribute("name", part)
#      CALL parent.setAttribute("isDir", "1")
#      --DISPLAY sfmt("created newchild for tag:%1,parentName:%2",part,parent.getAttribute("name"))
#      LET parent = newchild
#    END IF
#  END WHILE
#  RETURN parent
#END FUNCTION
#
#PRIVATE FUNCTION addFile(parent, path)
#  DEFINE parent, node om.DomNode
#  DEFINE path STRING
#  --DISPLAY "addFile:",path
#  LET node = findFileNode(parent, path, TRUE)
#  --DISPLAY "added:",node.toString()
#END FUNCTION
#
#PRIVATE FUNCTION fileExists(root, name)
#  DEFINE root, node om.DomNode
#  DEFINE name STRING
#  LET node = findFileNode(root, name, FALSE)
#  RETURN node IS NOT NULL
#END FUNCTION
#
#PRIVATE FUNCTION isDir(root, name)
#  DEFINE root, node om.DomNode
#  DEFINE name STRING
#  LET node = findFileNode(root, name, FALSE)
#  RETURN node IS NOT NULL AND node.getTagName() == "Dir"
#END FUNCTION
#
#PRIVATE FUNCTION analyze(root)
#  DEFINE root, child {, lastChild} om.DomNode
#  DEFINE numChildren INT
#  --DEFINE children DYNAMIC ARRAY OF om.DomNode
#  LET child = root.getFirstChild()
#  WHILE child IS NOT NULL
#    LET numChildren = numChildren + 1
#    --LET children[children.getLength()+1]=child.getAttribute("name")
#    --LET lastChild = child
#    LET child = child.getNext()
#  END WHILE
#  CALL root.setAttribute("numChildren", numChildren)
#  RETURN numChildren
#END FUNCTION
#
#PRIVATE FUNCTION getNumChildren(root)
#  DEFINE root om.DomNode
#  RETURN root.getAttribute("numChildren")
#END FUNCTION
#
#PRIVATE FUNCTION doit(root, numChildren)
#  DEFINE root om.DomNode
#  DEFINE numChildren INT
#  DEFINE defRoot STRING
#  {
#  IF _opt_ext_dir IS NOT NULL THEN
#    CALL mkdirp(_opt_ext_dir)
#    MYASSERT(os.Path.chDir(_opt_ext_dir) == TRUE)
#  END IF
#  }
#  IF numChildren == 1 THEN --single root , no need to compute one
#    IF _opt_in_FGLDIR THEN
#      CALL userError(
#          "This package is not prepared to be installed over FGLDIR(yet).")
#    END IF
#    CALL unzip(root)
#  ELSE
#    IF _opt_in_FGLDIR THEN
#      CALL unzipOverFGLDIR(root)
#    ELSE
#      IF NOT _opt_plain THEN --by default create a single root directory to avoid cluttering the current directory with multiple files and extract the zip beneath that single root directory
#        LET defRoot = computeDefName()
#        IF NOT os.Path.exists(defRoot) THEN
#          CALL mkdirp(defRoot)
#          IF _opt_verbose THEN
#            DISPLAY "created extraction root:", os.Path.fullPath(defRoot)
#          END IF
#        END IF
#        MYASSERT(os.Path.chDir(defRoot) == TRUE)
#      ELSE
#        IF NOT _opt_simulate AND NOT _opt_undo THEN
#          CALL checkFilesExisting(root)
#        END IF
#      END IF
#      CALL unzip(root)
#    END IF
#  END IF
#END FUNCTION
#
#PRIVATE FUNCTION unzip(root)
#  DEFINE root om.DomNode
#  DEFINE cmd STRING
#  DEFINE code INT
#  IF _opt_simulate THEN
#    IF _opt_undo THEN
#      DISPLAY "Would remove in:", os.Path.pwd()
#      DISPLAY "(N no file/dir) (D remove dir if empty) (F remove File) (C conflict)"
#    ELSE
#      DISPLAY "Would extract in:", os.Path.pwd()
#      DISPLAY "(N new file/dir) (D overwrite dir) (F overwrite File) (C conflict)"
#    END IF
#    CALL simulate(root, os.Path.pwd())
#    RETURN
#  END IF
#  IF _opt_undo THEN
#    CALL undo(root, os.Path.pwd())
#    RETURN
#  END IF
#  --CALL generateUndoScript(root)
#  LET cmd = SFMT("%1 xf %2", tarExe(), quote(_product_zip))
#  IF _opt_verbose THEN
#    DISPLAY "unzip cmd:", cmd
#  END IF
#  RUN cmd RETURNING code
#  IF code THEN
#    EXIT PROGRAM code
#  END IF
#  CALL verify(root, os.Path.pwd())
#END FUNCTION
#
#PRIVATE FUNCTION undo(parent, parentDir)
#  DEFINE parent, child om.DomNode
#  DEFINE parentDir, path, tag STRING
#  LET child = parent.getFirstChild()
#  WHILE child IS NOT NULL
#    LET path = os.Path.join(parentDir, child.getAttribute("name"))
#    LET tag = child.getTagName()
#    IF tag == "File" THEN
#      IF os.Path.exists(path) THEN
#        IF NOT os.Path.delete(path) THEN
#          DISPLAY "couldn't delete:", path
#        ELSE
#          IF _opt_verbose THEN
#            DISPLAY "deleted file:", path
#          END IF
#        END IF
#      END IF
#    END IF
#    CALL undo(child, path)
#    IF tag == "Dir" THEN
#      IF os.Path.exists(path) AND os.Path.isDirectory(path) THEN
#        IF NOT os.Path.delete(path) THEN
#          DISPLAY "Could not delete dir:", path, ",probably not empty"
#        ELSE
#          IF _opt_verbose THEN
#            DISPLAY "deleted dir:", path, "/"
#          END IF
#        END IF
#      END IF
#    END IF
#    LET child = child.getNext()
#  END WHILE
#END FUNCTION
#
##+check if the unzip command did work
#PRIVATE FUNCTION verify(parent, parentDir)
#  DEFINE parent, child om.DomNode
#  DEFINE parentDir, path, tag STRING
#  LET child = parent.getFirstChild()
#  WHILE child IS NOT NULL
#    LET path = os.Path.join(parentDir, child.getAttribute("name"))
#    LET tag = child.getTagName()
#    CASE
#      WHEN tag == "Dir"
#        MYASSERT(os.Path.isDirectory(path))
#      WHEN tag == "File"
#        MYASSERT(os.Path.isFile(path))
#      OTHERWISE
#        CALL myErr(SFMT("unexpected tagName:%1", tag))
#    END CASE
#    IF _opt_verbose THEN
#      DISPLAY "verified:", path
#    END IF
#    CALL verify(child, path)
#    LET child = child.getNext()
#  END WHILE
#END FUNCTION
#
##+check if the unzip command did work
#PRIVATE FUNCTION simulate(parent, parentDir)
#  DEFINE parent, child om.DomNode
#  DEFINE parentDir, path, tag, marker STRING
#  LET child = parent.getFirstChild()
#  WHILE child IS NOT NULL
#    LET path = os.Path.join(parentDir, child.getAttribute("name"))
#    LET tag = child.getTagName()
#    CASE
#      WHEN tag == "Dir"
#        IF os.Path.exists(path) THEN
#          LET marker = IIF(os.Path.isFile(path), "C", "D")
#        ELSE
#          LET marker = "N"
#        END IF
#        DISPLAY SFMT("%1 %2%3", marker, path, os.Path.separator())
#        IF marker == "C" THEN
#          DISPLAY "  expected: directory, actual: file"
#        END IF
#      WHEN tag == "File"
#        IF os.Path.exists(path) THEN
#          LET marker = IIF(os.Path.isDirectory(path), "C", "F")
#        ELSE
#          LET marker = "N"
#        END IF
#        DISPLAY SFMT("%1 %2", marker, path)
#        IF marker == "C" THEN
#          DISPLAY "  expected: file, actual: directory"
#        END IF
#      OTHERWISE
#        CALL myErr(SFMT("unexpected tagName:%1", tag))
#    END CASE
#    CALL simulate(child, path)
#    LET child = child.getNext()
#  END WHILE
#END FUNCTION
#
#PRIVATE FUNCTION checkFilesExisting(root)
#  DEFINE root om.DomNode
#  DEFINE dh INT
#  DEFINE fname, ans STRING
#  DEFINE foundEntries INT
#  LET dh = os.Path.dirOpen(os.Path.pwd())
#  IF dh == 0 THEN
#    CALL userError(SFMT("Can't open directory '%1'", os.Path.pwd()))
#  END IF
#  WHILE (fname := os.Path.dirNext(dh)) IS NOT NULL
#    IF fname == "." OR fname == ".." THEN
#      CONTINUE WHILE
#    END IF
#    LET foundEntries = foundEntries + 1
#  END WHILE
#  CALL os.Path.dirClose(dh)
#  IF foundEntries > 0 THEN
#    LET ans =
#        yesno(
#            SFMT("There are already %1 files, folders or links in this directory...\nContinue extracting %2 files ?",
#                foundEntries, getNumChildren(root)))
#    --DISPLAY "ans:",ans
#    IF NOT ans.equals("yes") THEN
#      EXIT PROGRAM 1
#    END IF
#  END IF
#END FUNCTION
#
#PRIVATE FUNCTION isGBC(root)
#  DEFINE root om.DomNode
#  RETURN fileExists(root, "VERSION")
#      AND fileExists(root, "PRODUCTINFO")
#      AND fileExists(root, "index.html")
#      AND fileExists(root, "js/gbc.js")
#END FUNCTION
#
#PRIVATE FUNCTION myChdir(path)
#  DEFINE path STRING
#  IF NOT os.Path.chDir(path) THEN
#    CALL myErr(SFMT("Can't chdir to:%1", path))
#  END IF
#END FUNCTION
#
#PRIVATE FUNCTION getFglDir()
#  RETURN base.Application.getFglDir()
#END FUNCTION
#
#PRIVATE FUNCTION unzipGBCoverFGLDIR(root)
#  DEFINE root om.DomNode
#  DEFINE gbcDir STRING
#  LET gbcDir = SFMT("%1/web_utilities/gbc/gbc", getFglDir())
#  CALL mkdirp(gbcDir)
#  CALL myChdir(gbcDir)
#  CALL unzip(root)
#END FUNCTION
#
#PRIVATE FUNCTION unzipOverFGLDIR(root)
#  DEFINE root om.DomNode
#  IF isGBC(root) THEN
#    CALL unzipGBCoverFGLDIR(root)
#  ELSE
#    CALL myChdir(getFglDir())
#    CALL unzip(root)
#  END IF
#END FUNCTION
#
#PRIVATE FUNCTION generateUndoScript(root)
#  DEFINE root om.DomNode
#  DEFINE ch_sh, ch_bat base.Channel
#  DEFINE name_sh, name_bat STRING
#  LET ch_sh = base.Channel.create()
#  LET name_sh = SFMT("rm-%1.sh", computeDefName())
#  CALL ch_sh.openFile(name_sh, "w")
#  CALL ch_sh.writeLine("#!/bin/bash")
#  IF isWin() THEN
#    LET ch_bat = base.Channel.create()
#    LET name_bat = SFMT("rm-%1.bat", computeDefName())
#    CALL ch_bat.openFile(name_bat, "w")
#    CALL ch_bat.writeLine("@echo off")
#  END IF
#  CALL add_rm(root, ".", ch_sh, ch_bat)
#  CALL ch_sh.writeLine(SFMT("rm -f %1", quote(name_sh)))
#  CALL ch_sh.close()
#  MYASSERT(os.Path.chRwx(name_sh, 484) == TRUE) --u+x
#END FUNCTION
#
#PRIVATE FUNCTION add_rm(parent, parentDir, ch_sh, ch_bat)
#  DEFINE parent, child om.DomNode
#  DEFINE parentDir, path, winpath STRING
#  DEFINE ch_sh, ch_bat base.Channel
#  LET child = parent.getFirstChild()
#  WHILE child IS NOT NULL
#    LET path = SFMT("%1/%2", parentDir, child.getAttribute("name"))
#    LET winpath = replace(path, "/", "\\")
#    IF child.getTagName() == "File" THEN
#      CALL ch_sh.writeLine(SFMT("rm -f %1", quote(path)))
#      IF isWin() THEN
#        CALL ch_bat.writeLine(SFMT("del /Q %1", quote(winpath)))
#      END IF
#    END IF
#    CALL add_rm(child, path, ch_sh, ch_bat)
#    IF child.getTagName() == "Dir" THEN
#      CALL ch_sh.writeLine(SFMT("rmdir %1", quote(path)));
#      IF isWin() THEN
#        CALL ch_bat.writeLine(SFMT("rmdir %1", quote(winpath)));
#      END IF
#    END IF
#    LET child = child.getNext()
#  END WHILE
#END FUNCTION
#
##+ for zip archives not having a single root we create a root dir named after the product file name (similar to what desktop extraction tools do)
#PRIVATE FUNCTION computeDefName()
#  DEFINE def, b STRING
#  DEFINE idx1, idx2 INT
#  LET b = os.Path.baseName(_product_zip)
#  IF b.getIndexOf("fjs-", 1) == 1 THEN
#    LET idx1 = b.getIndexOf("-", 5)
#    MYASSERT(idx1 != 0)
#    LET idx2 = b.getIndexOf("-", idx1 + 1)
#    LET def = b.subString(5, idx2 - 1)
#  ELSE
#    LET def = removeExtension(b)
#  END IF
#  --DISPLAY "defname:", def
#  RETURN def
#END FUNCTION
#
#--utils
#
#PRIVATE FUNCTION isWin() RETURNS BOOLEAN
#  RETURN os.Path.separator().equals("\\")
#END FUNCTION
#
#PRIVATE FUNCTION printStderr(errstr STRING)
#  DEFINE ch base.Channel
#  LET ch = base.Channel.create()
#  CALL ch.openFile("<stderr>", "w")
#  CALL ch.writeLine(errstr)
#  CALL ch.close()
#END FUNCTION
#{
#PRIVATE FUNCTION printStdout(str STRING, noNewLine BOOLEAN)
#  IF noNewLine THEN
#    LET _stdoutNONL = _stdoutNONL, str
#  ELSE
#    LET str = _stdoutNONL, str
#    LET _stdoutNONL = ""
#    DISPLAY str
#  END IF
#END FUNCTION
#}
#
#PRIVATE FUNCTION myErr(errstr STRING)
#  CALL printStderr(
#      SFMT("ERROR:%1 stack:\n%2", errstr, base.Application.getStackTrace()))
#  EXIT PROGRAM 1
#END FUNCTION
#{
#PRIVATE FUNCTION myWarning(errstr STRING)
#  CALL printStderr(SFMT("Warning %1:%2", progName(), errstr))
#END FUNCTION
#
#PRIVATE FUNCTION log(msg STRING)
#  IF fgl_getenv("VERBOSE") IS NOT NULL THEN
#    DISPLAY "log:", msg
#  END IF
#END FUNCTION
#
#--for dev: replace log() with dlog() for simply write to stdout
#PRIVATE FUNCTION dlog(s STRING)
#  DISPLAY s
#END FUNCTION
#}
#
#PRIVATE FUNCTION already_quoted(path) RETURNS BOOLEAN
#  DEFINE path, first, last STRING
#  LET first = NVL(path.getCharAt(1), "NULL")
#  LET last = NVL(path.getCharAt(path.getLength()), "NULL")
#  IF isWin() THEN
#    RETURN (first == '"' AND last == '"')
#  END IF
#  RETURN (first == "'" AND last == "'") OR (first == '"' AND last == '"')
#END FUNCTION
#
#PRIVATE FUNCTION quote(path STRING) RETURNS STRING
#  RETURN quoteInt(path, FALSE)
#END FUNCTION
#
#PRIVATE FUNCTION quoteForce(path STRING) RETURNS STRING
#  RETURN quoteInt(path, TRUE)
#END FUNCTION
#
#PRIVATE FUNCTION quoteInt(path STRING, force BOOLEAN) RETURNS STRING
#  IF force OR path.getIndexOf(" ", 1) > 0 THEN
#    IF NOT already_quoted(path) THEN
#      LET path = '"', path, '"'
#    END IF
#  ELSE
#    IF already_quoted(path) AND isWin() THEN --remove quotes(Windows)
#      LET path = path.subString(2, path.getLength() - 1)
#    END IF
#  END IF
#  RETURN path
#END FUNCTION
#
#PRIVATE FUNCTION replace(
#    src STRING, oldStr STRING, newString STRING)
#    RETURNS STRING
#  DEFINE b base.StringBuffer
#  LET b = base.StringBuffer.create()
#  CALL b.append(src)
#  CALL b.replace(oldStr, newString, 0)
#  RETURN b.toString()
#END FUNCTION
#
#PRIVATE FUNCTION backslash2slash(src STRING) RETURNS STRING
#  RETURN replace(src, "\\", "/")
#END FUNCTION
#
##+case insensitive variant of getIndexOf
#PRIVATE FUNCTION getIndexOfI(src, pattern, idx) RETURNS INT
#  DEFINE src, pattern STRING
#  DEFINE idx INTEGER
#  LET src = src.toLowerCase()
#  RETURN src.getIndexOf(pattern.toLowerCase(), idx)
#END FUNCTION
#
#PRIVATE FUNCTION getProgramOutputWithErr(cmd STRING) RETURNS(STRING, STRING)
#  DEFINE cmdOrig, tmpName, errStr STRING
#  DEFINE txt TEXT
#  DEFINE ret STRING
#  DEFINE code INT
#  LET cmdOrig = cmd
#  LET tmpName = makeTempName()
#  LET cmd = cmd, ">", tmpName, " 2>&1"
#  --CALL log(sfmt("run:%1", cmd))
#  RUN cmd RETURNING code
#  LOCATE txt IN FILE tmpName
#  LET ret = txt
#  CALL os.Path.delete(tmpName) RETURNING status
#  IF code THEN
#    LET errStr = ",\noutput:", ret
#    CALL os.Path.delete(tmpName) RETURNING code
#  ELSE
#    --remove \r\n
#    IF ret.getCharAt(ret.getLength()) == "\n" THEN
#      LET ret = ret.subString(1, ret.getLength() - 1)
#    END IF
#    IF ret.getCharAt(ret.getLength()) == "\r" THEN
#      LET ret = ret.subString(1, ret.getLength() - 1)
#    END IF
#  END IF
#  RETURN ret, errStr
#END FUNCTION
#
#PRIVATE FUNCTION getProgramOutput(cmd STRING) RETURNS STRING
#  DEFINE result, err STRING
#  CALL getProgramOutputWithErr(cmd) RETURNING result, err
#  IF err IS NOT NULL THEN
#    CALL userError(SFMT("failed to RUN:%1%2", cmd, err))
#  END IF
#  RETURN result
#END FUNCTION
#
##+computes a temporary file name
#PRIVATE FUNCTION makeTempName() RETURNS STRING
#  DEFINE tmpDir, tmpName, sbase, curr STRING
#  DEFINE sb base.StringBuffer
#  DEFINE i INT
#  IF isWin() THEN
#    LET tmpDir = fgl_getenv("TEMP")
#  ELSE
#    LET tmpDir = "/tmp"
#  END IF
#  LET curr = CURRENT
#  LET sb = base.StringBuffer.create()
#  CALL sb.append(curr)
#  CALL sb.replace(" ", "_", 0)
#  CALL sb.replace(":", "_", 0)
#  CALL sb.replace(".", "_", 0)
#  CALL sb.replace("-", "_", 0)
#  LET sbase = SFMT("fgl_%1_%2", fgl_getpid(), sb.toString())
#  LET sbase = os.Path.join(tmpDir, sbase)
#  FOR i = 1 TO 10000
#    LET tmpName = SFMT("%1%2.tmp", sbase, i)
#    IF NOT os.Path.exists(tmpName) THEN
#      RETURN tmpName
#    END IF
#  END FOR
#  CALL myErr("makeTempName:Can't allocate a unique name")
#  RETURN NULL
#END FUNCTION
#
#-- returns
#-- -<count>-g<SHA> for a non release
#-- -<SHA> for a release (GIT_COMMIT_COUNT==0)
#PRIVATE FUNCTION adjustGitCountAndRev(cnt INT, rev STRING)
#  --don't display 0 and g in the revision for official releases
#  VAR countInfo = IIF(cnt == 0, "", SFMT("-%1", cnt))
#  LET rev = IIF(cnt == 0, rev.subString(2, rev.getLength()), rev)
#  VAR ret = SFMT("%1-%2", countInfo, rev)
#  VAR warn
#      = IIF(cnt == 0,
#          "",
#          " (nightly build - not suitable for production purposes)")
#  LET ret = SFMT("%1%2", ret, warn)
#  RETURN ret
#END FUNCTION
#
#PRIVATE FUNCTION removeExtension(fname STRING) RETURNS STRING
#  VAR ext = os.Path.extension(fname)
#  IF ext.getLength() > 0 THEN
#    LET fname = fname.subString(1, fname.getLength() - (ext.getLength() + 1))
#  END IF
#  RETURN fname
#END FUNCTION
#
#PRIVATE FUNCTION printVersion()
#  VAR prog = removeExtension(os.Path.baseName(arg_val(0)))
#  DISPLAY SFMT("%1 %2 rev%3",
#      prog, GIT_VERSION, adjustGitCountAndRev(GIT_COMMIT_COUNT, GIT_REV))
#  EXIT PROGRAM 0
#END FUNCTION
#
#PRIVATE FUNCTION isLetter(c STRING)
#  VAR letters = "abcdefghijklmnopqrstuvwxyz"
#  RETURN getIndexOfI(src: letters, pattern: c, idx: 1) > 0
#END FUNCTION
#
#PRIVATE FUNCTION isWinDriveInt(path STRING)
#  RETURN isWin()
#      AND path.getCharAt(2) == ":"
#      AND (path.getCharAt(3) == "\\" OR path.getCharAt(3) == "/")
#      AND isLetter(path.getCharAt(1))
#END FUNCTION
#{
#PRIVATE FUNCTION isWinDriveRoot(path STRING)
#  RETURN path.getLength() == 3 AND isWinDriveInt(path)
#END FUNCTION
#}
#
#PRIVATE FUNCTION pathStartsWithWinDrive(path STRING)
#  RETURN path.getLength() >= 3 AND isWinDriveInt(path)
#END FUNCTION
#
##creates a directory path recursively like mkdir -p
#PRIVATE FUNCTION mkdirp(path STRING)
#  VAR winbase = FALSE
#  VAR level = 0
#  IF isWin() AND path.getIndexOf("\\", 1) > 0 THEN
#    LET path = backslash2slash(path)
#  END IF
#  VAR basedir = "."
#  CASE
#    WHEN path.getCharAt(1) == "/"
#      LET basedir = "/"
#      --check for driveletter: as path start
#    WHEN pathStartsWithWinDrive(path)
#      LET basedir = path.subString(1, 2)
#      --DISPLAY "winbase:",basedir
#      LET winbase = TRUE
#  END CASE
#  VAR tok = base.StringTokenizer.create(path, "/")
#  VAR part = basedir
#  WHILE tok.hasMoreTokens()
#    LET level = level + 1
#    VAR next = tok.nextToken()
#    --DISPLAY "part0:",part,",next:",next
#    IF level == 1 AND winbase THEN
#      MYASSERT(basedir == next)
#      --DISPLAY "next level"
#      CONTINUE WHILE
#    END IF
#    LET part = os.Path.join(part, next)
#    --DISPLAY "part1:",part
#    IF NOT os.Path.exists(part) THEN
#      IF NOT os.Path.mkdir(part) THEN
#        CALL myErr(SFMT("can't create directory:%1", part))
#        {ELSE
#          DISPLAY "did mkdir:", part}
#      END IF
#    ELSE
#      IF NOT os.Path.isDirectory(part) THEN
#        CALL myErr(SFMT("mkdirp: sub path:'%1' is not a directory", part))
#        {ELSE
#          DISPLAY "part next:", part, " is a dir"}
#      END IF
#    END IF
#  END WHILE
#END FUNCTION
#
#PRIVATE FUNCTION progName() RETURNS STRING
#  VAR ret = os.Path.baseName(arg_val(0))
#  VAR ext = os.Path.extension(ret)
#  IF ext.getLength() > 0 THEN
#    LET ret = ret.subString(1, ret.getLength() - ext.getLength() - 1)
#  END IF
#  RETURN ret
#END FUNCTION
#
#PRIVATE FUNCTION userError(err STRING)
#  CALL printStderr(SFMT("Error %1:%2", progName(), err))
#  EXIT PROGRAM 1
#END FUNCTION
#
#PRIVATE FUNCTION whichExe(prog STRING) RETURNS STRING
#  DEFINE exe, err, cmd STRING
#  LET cmd = IIF(isWin(), "where", "which")
#  CALL getProgramOutputWithErr(SFMT("%1 %2", cmd, quote(prog)))
#      RETURNING exe, err
#  IF err IS NOT NULL THEN
#    --DISPLAY SFMT("which error for '%1':%2", prog, err)
#    RETURN NULL
#  END IF
#  RETURN exe
#END FUNCTION
#
#PRIVATE FUNCTION fullfglrunEXE()
#  RETURN os.Path.join(
#      os.Path.join(base.Application.getFglDir(), "bin"),
#      SFMT("fglrun%1", IIF(isWin(), ".exe", "")))
#END FUNCTION
#
#PRIVATE FUNCTION fullProgName()
#  RETURN os.Path.join(
#      base.Application.getProgramDir(), os.Path.baseName(arg_val(0)))
#END FUNCTION
#
#PRIVATE FUNCTION writeStringToFile(file STRING, content STRING)
#  DEFINE ch base.Channel
#  LET ch = base.Channel.create()
#  CALL ch.openFile(file, "w")
#  CALL ch.writeNoNL(content)
#  CALL ch.close()
#END FUNCTION
#
#FUNCTION readTextFile(filename) RETURNS STRING
#  DEFINE filename STRING
#  DEFINE content STRING
#  DEFINE t TEXT
#  LOCATE t IN FILE filename
#  LET content = t
#  RETURN content
#END FUNCTION
#
#FUNCTION yesno_mode()
#  DEFINE yesno_msg STRING
#  LET yesno_msg = fgl_getenv("__FGL_UNZIP_YESNO_MESSAGE__")
#  IF yesno_msg IS NOT NULL THEN --we did invoke us for yesno
#    CALL yesno(yesno_msg) RETURNING status
#    RETURN TRUE
#  END IF
#  RETURN FALSE
#END FUNCTION
#
#PRIVATE FUNCTION yesno_cmd(message)
#  DEFINE message STRING
#  DEFINE cmd, ans, resfile STRING
#  DEFINE code INT
#  CALL fgl_setenv("FGLGUI", "0")
#  CALL fgl_setenv("__FGL_UNZIP_YESNO_MESSAGE__", message)
#  LET resfile = makeTempName()
#  CALL fgl_setenv("__FGL_UNZIP_RESULT_FILE__", resfile)
#  LET cmd = SFMT("%1 %2", quote(fullfglrunEXE()), quote(fullProgName()))
#  --DISPLAY "cmd:",cmd
#  RUN cmd RETURNING code
#  IF code THEN
#    LET ans = "failed"
#  ELSE
#    LET ans = readTextFile(resfile)
#  END IF
#  CALL os.Path.delete(resfile) RETURNING status
#  RETURN ans
#END FUNCTION
#
#--displays a multiline message in a temp .42f
#--and calls a MENU with yes no
#PRIVATE FUNCTION yesno(message)
#  DEFINE message STRING
#  DEFINE fglgui, ans, resfile, frmfile STRING
#  LET fglgui = fgl_getenv("FGLGUI")
#  IF NOT fglgui.equals("0") THEN --run sub process
#    RETURN yesno_cmd(message)
#  END IF
#  LET resfile = fgl_getenv("__FGL_UNZIP_RESULT_FILE__")
#  LET frmfile = makeTempName(), ".42f"
#  CALL writeStringToFile(frmfile, fglunzip_42f())
#  OPTIONS MENU LINE 5
#  OPTIONS COMMENT LINE 6
#  OPEN FORM f FROM frmfile
#  DISPLAY FORM f
#  CALL os.Path.delete(frmfile) RETURNING status
#  DISPLAY message TO msg
#  MENU " Please answer"
#    COMMAND "yes"
#      LET ans = "yes"
#      EXIT MENU
#    COMMAND "no"
#      LET ans = "no"
#      EXIT MENU
#  END MENU
#  IF resfile IS NOT NULL THEN
#    CALL writeStringToFile(resfile, content: ans)
#  END IF
#  RETURN ans
#END FUNCTION
#
#--returns fglunzip.per ready compiled
#FUNCTION fglunzip_42f()
#  RETURN '<?xml version=\'1.0\' encoding=\'UTF-8\'?>\n<Form name="fglunzip" build="5.01.02" width="80" height="2" delimiters="">\n<Screen width="80" height="2">\n<FormField name="formonly.msg" colName="msg" fieldId="0" sqlTabName="formonly" tabIndex="1">\n<TextEdit wantReturns="1" scrollBars="none" scroll="0" height="2" width="78" posY="0" posX="1" gridWidth="78" gridHeight="2"/>\n</FormField>\n</Screen>\n<RecordView tabName="formonly">\n<Link colName="msg" fieldIdRef="0"/>\n</RecordView>\n</Form>'
#END FUNCTION
#--SCREEN
#--{
#--[msg                                                                           ]
#--[msg                                                                           ]
#--}
#--END
#--ATTRIBUTES
#
#--msg=FORMONLY.msg,WORDWRAP;
#--INSTRUCTIONS
#--DELIMITERS "";
#__CAT_EOF_END__
